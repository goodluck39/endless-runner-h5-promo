<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048 游戏</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Clear+Sans:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --board-bg: #bbada0;
            --grid-gap: 15px;
            --tile-size: 100px;
            --border-radius: 6px;
        }

        body {
            font-family: "Clear Sans", Arial, sans-serif;
            background-color: #faf8ef;
            color: #776e65;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            touch-action: none; /* 禁用移动设备上的默认触摸行为，如缩放 */
        }

        .container {
            width: 100%;
            max-width: 500px;
            text-align: center;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 80px;
            font-weight: bold;
            margin: 0;
            color: #776e65;
        }

        .scores {
            display: flex;
            gap: 8px;
        }

        .score-container {
            background-color: var(--board-bg);
            padding: 15px 25px;
            border-radius: var(--border-radius);
            font-size: 16px;
            font-weight: bold;
            color: #eee4da;
            display: flex;
            flex-direction: column;
            min-width: 80px;
        }
        .score-container span {
            font-size: 25px;
            font-weight: bold;
            color: white;
            margin-top: 2px;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .instructions {
            margin-top: 20px;
            font-size: 16px;
            color: #776e65;
        }

        #new-game-btn {
            background-color: #8f7a66;
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: var(--border-radius);
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #new-game-btn:hover {
            background-color: #9f8b77;
        }

        #game-board-container {
            position: relative;
            background-color: var(--board-bg);
            border-radius: var(--border-radius);
            padding: var(--grid-gap);
            /* Calculate container size based on tiles and gaps */
            width: calc(var(--tile-size) * 4 + var(--grid-gap) * 5);
            height: calc(var(--tile-size) * 4 + var(--grid-gap) * 5);
            box-sizing: border-box;
        }
        
        .grid-background {
            display: grid;
            grid-template-columns: repeat(4, var(--tile-size));
            grid-template-rows: repeat(4, var(--tile-size));
            gap: var(--grid-gap);
        }

        .grid-cell {
            width: var(--tile-size);
            height: var(--tile-size);
            background-color: #cdc1b4;
            border-radius: var(--border-radius);
        }

        .tile-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .tile {
            position: absolute;
            width: var(--tile-size);
            height: var(--tile-size);
            border-radius: var(--border-radius);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 45px;
            font-weight: bold;
            box-sizing: border-box;
            transition: transform 100ms ease-in-out;
            
            /* Animation for spawning */
            animation: spawn 200ms ease-in-out;
        }
        
        @keyframes spawn {
            0% { transform: scale(0); }
            100% { transform: scale(1); }
        }

        .tile.merged {
            animation: merge 200ms ease-in-out;
        }

        @keyframes merge {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }


        /* --- Tile Colors --- */
        .tile[data-value="2"] { background-color: #a2e4b8; color: #776e65; } /* 这是修改后的颜色 */
        .tile[data-value="4"] { background-color: #ede0c8; color: #776e65; }
        .tile[data-value="8"] { background-color: #f2b179; color: #f9f6f2; }
        .tile[data-value="16"] { background-color: #f59563; color: #f9f6f2; }
        .tile[data-value="32"] { background-color: #f67c5f; color: #f9f6f2; }
        .tile[data-value="64"] { background-color: #f65e3b; color: #f9f6f2; }
        .tile[data-value="128"] { background-color: #edcf72; color: #f9f6f2; font-size: 40px; box-shadow: 0 0 30px 10px rgba(243, 215, 116, 0.238); }
        .tile[data-value="256"] { background-color: #edcc61; color: #f9f6f2; font-size: 40px; box-shadow: 0 0 30px 10px rgba(243, 215, 116, 0.317); }
        .tile[data-value="512"] { background-color: #edc850; color: #f9f6f2; font-size: 40px; box-shadow: 0 0 30px 10px rgba(243, 215, 116, 0.397); }
        .tile[data-value="1024"] { background-color: #edc53f; color: #f9f6f2; font-size: 35px; box-shadow: 0 0 30px 10px rgba(243, 215, 116, 0.476); }
        .tile[data-value="2048"] { background-color: #edc22e; color: #f9f6f2; font-size: 35px; box-shadow: 0 0 30px 10px rgba(243, 215, 116, 0.556); }
        .tile[data-value="4096"] { background-color: #3c3a32; color: #f9f6f2; font-size: 35px; box-shadow: 0 0 30px 10px rgba(60, 58, 50, 0.556); }


        #game-message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(238, 228, 218, 0.73);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 55px;
            font-weight: bold;
            color: #776e65;
            z-index: 100;
            transition: opacity 0.3s, visibility 0.3s;
            opacity: 0;
            visibility: hidden;
        }

        #game-message-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        
        #game-message-text {
            margin-bottom: 20px;
        }

        #restart-btn, #continue-btn {
            background-color: #8f7a66;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: var(--border-radius);
            font-size: 20px;
            cursor: pointer;
            margin: 5px;
        }
        #restart-btn:hover, #continue-btn:hover {
            background-color: #9f8b77;
        }

        /* Responsive design for smaller screens */
        @media (max-width: 520px) {
            :root {
                --tile-size: 65px;
                --grid-gap: 10px;
            }
            h1 { font-size: 50px; }
            .score-container { padding: 10px 15px; min-width: 60px; }
            .score-container span { font-size: 18px; }
            .tile { font-size: 25px; }
            .tile[data-value="1024"] { font-size: 20px; }
            .tile[data-value="2048"] { font-size: 20px; }
            .tile[data-value="4096"] { font-size: 20px; }
            #game-message-overlay { font-size: 40px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>2048</h1>
            <div class="scores">
                <div class="score-container">得分 <span id="score">0</span></div>
                <div class="score-container">最佳 <span id="high-score">0</span></div>
            </div>
        </div>
        <div class="controls">
            <p class="instructions">使用方向键或滑动来移动方块！</p>
            <button id="new-game-btn">新游戏</button>
        </div>
        <div id="game-board-container">
            <div class="grid-background">
                </div>
            <div class="tile-container">
                </div>

            <div id="game-message-overlay">
                <div id="game-message-text">游戏结束!</div>
                <div id="game-message-buttons">
                    <button id="restart-btn">再试一次</button>
                    <button id="continue-btn" style="display: none;">继续游戏</button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const gameBoardContainer = document.getElementById('game-board-container');
            const tileContainer = gameBoardContainer.querySelector('.tile-container');
            const gridBackground = gameBoardContainer.querySelector('.grid-background');
            const scoreDisplay = document.getElementById('score');
            const highScoreDisplay = document.getElementById('high-score');
            const newGameBtn = document.getElementById('new-game-btn');
            
            const messageOverlay = document.getElementById('game-message-overlay');
            const messageText = document.getElementById('game-message-text');
            const restartBtn = document.getElementById('restart-btn');
            const continueBtn = document.getElementById('continue-btn');

            const gridSize = 4;
            let board = [];
            let tiles = [];
            let score = 0;
            let highScore = 0;
            let isGameLocked = false;
            let hasWon = false;

            // --- Game Initialization ---
            function initGame() {
                board = Array(gridSize).fill(null).map(() => Array(gridSize).fill(0));
                score = 0;
                hasWon = false;
                isGameLocked = false;
                loadHighScore();
                updateScore(0);
                
                messageOverlay.classList.remove('show');
                
                setupBackgroundGrid();
                tileContainer.innerHTML = '';
                tiles = [];

                addRandomTile();
                addRandomTile();
            }

            function setupBackgroundGrid() {
                gridBackground.innerHTML = '';
                for (let i = 0; i < gridSize * gridSize; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    gridBackground.appendChild(cell);
                }
            }

            // --- Rendering and Animation ---
            function renderBoard() {
                for (let i = 0; i < tiles.length; i++) {
                    const tile = tiles[i];
                    if (tile.merged) {
                        // Handle merged tile
                        const mergedIntoTile = tiles.find(t => t.id === tile.mergedInto);
                        if(mergedIntoTile) {
                            mergedIntoTile.element.classList.add('merged');
                            mergedIntoTile.element.textContent = mergedIntoTile.value;
                            mergedIntoTile.element.setAttribute('data-value', mergedIntoTile.value);
                        }
                        tile.element.remove();
                    } else {
                        // Handle moved tile
                        const gap = getComputedStyle(document.documentElement).getPropertyValue('--grid-gap');
                        const size = getComputedStyle(document.documentElement).getPropertyValue('--tile-size');
                        const x = `calc(${tile.c} * (${size} + ${gap}) + ${gap})`;
                        const y = `calc(${tile.r} * (${size} + ${gap}) + ${gap})`;
                        tile.element.style.transform = `translate(${x}, ${y})`;
                    }
                }

                // Clean up merged tiles from the main array
                tiles = tiles.filter(tile => !tile.merged);
            }

            function addRandomTile() {
                const emptyTiles = [];
                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        if (board[r][c] === 0) {
                            emptyTiles.push({ r, c });
                        }
                    }
                }

                if (emptyTiles.length > 0) {
                    const { r, c } = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
                    const value = Math.random() < 0.9 ? 2 : 4;
                    board[r][c] = value;
                    createTile(r, c, value);
                }
            }
            
            function createTile(r, c, value) {
                const tileElement = document.createElement('div');
                tileElement.className = 'tile';
                tileElement.textContent = value;
                tileElement.setAttribute('data-value', value);

                const newTile = {
                    id: Date.now() + Math.random(), // Unique ID
                    r,
                    c,
                    value,
                    element: tileElement
                };
                tiles.push(newTile);
                tileContainer.appendChild(tileElement);
                
                // Set initial position for animation
                const gap = getComputedStyle(document.documentElement).getPropertyValue('--grid-gap');
                const size = getComputedStyle(document.documentElement).getPropertyValue('--tile-size');
                const x = `calc(${c} * (${size} + ${gap}) + ${gap})`;
                const y = `calc(${r} * (${size} + ${gap}) + ${gap})`;
                tileElement.style.transform = `translate(${x}, ${y})`;
            }

            // --- Score Management ---
            function updateScore(points) {
                score += points;
                scoreDisplay.textContent = score;
                if (score > highScore) {
                    highScore = score;
                    highScoreDisplay.textContent = highScore;
                    localStorage.setItem('2048-highscore', highScore);
                }
            }

            function loadHighScore() {
                highScore = parseInt(localStorage.getItem('2048-highscore')) || 0;
                highScoreDisplay.textContent = highScore;
            }
            
            // --- Game Logic ---
            async function handleInput(direction) {
                if (isGameLocked) return;
                isGameLocked = true;

                const moveResult = move(direction);
                if (moveResult.changed) {
                    renderBoard();
                    // Wait for animations to finish
                    await new Promise(resolve => setTimeout(resolve, 100));

                    updateScore(moveResult.score);
                    
                    if (!hasWon) {
                        const has2048 = tiles.some(t => t.value === 2048);
                        if (has2048) {
                            winGame();
                            return; // Stop further processing
                        }
                    }
                    
                    addRandomTile();
                    
                    if (checkGameOver()) {
                        endGame();
                    }
                }
                
                isGameLocked = false;
            }
            
            function move(direction) {
                let changed = false;
                let moveScore = 0;
                
                // Create a temporary representation of the board using tile objects
                let tempBoard = Array(gridSize).fill(null).map(() => Array(gridSize).fill(null));
                tiles.forEach(t => tempBoard[t.r][t.c] = t);

                const getRow = (r) => tempBoard[r];
                const getCol = (c) => tempBoard.map(row => row[c]);
                const setRow = (r, newRow) => newRow.forEach((tile, c) => tempBoard[r][c] = tile);
                const setCol = (c, newCol) => newCol.forEach((tile, r) => tempBoard[r][c] = tile);

                const directions = {
                    'Up': { get: getCol, set: setCol, reverse: false },
                    'Down': { get: getCol, set: setCol, reverse: true },
                    'Left': { get: getRow, set: setRow, reverse: false },
                    'Right': { get: getRow, set: setRow, reverse: true },
                };

                const dir = directions[direction];

                for (let i = 0; i < gridSize; i++) {
                    const line = dir.get(i);
                    const originalLine = [...line];
                    if (dir.reverse) line.reverse();

                    // Slide
                    const filteredLine = line.filter(tile => tile !== null);
                    
                    // Merge
                    for (let j = 0; j < filteredLine.length - 1; j++) {
                        if (filteredLine[j].value === filteredLine[j + 1].value) {
                            const mergedTile = filteredLine[j];
                            const removedTile = filteredLine[j + 1];
                            
                            mergedTile.value *= 2;
                            moveScore += mergedTile.value;
                            
                            removedTile.merged = true; // Mark for removal
                            removedTile.mergedInto = mergedTile.id;

                            filteredLine.splice(j + 1, 1); // Remove from line
                        }
                    }

                    // Re-position tiles
                    filteredLine.forEach((tile, index) => {
                        if (direction === 'Up') { tile.r = index; tile.c = i; }
                        else if (direction === 'Down') { tile.r = gridSize - 1 - index; tile.c = i; }
                        else if (direction === 'Left') { tile.r = i; tile.c = index; }
                        else if (direction === 'Right') { tile.r = i; tile.c = gridSize - 1 - index; }
                    });
                    
                    const newLine = Array(gridSize).fill(null);
                    filteredLine.forEach((tile, index) => {
                        newLine[index] = tile;
                    });
                    
                    if (dir.reverse) newLine.reverse();
                    
                    // Check for changes
                    for (let k = 0; k < gridSize; k++) {
                        if ((originalLine[k] === null && newLine[k] !== null) || (originalLine[k] !== null && newLine[k] === null) || (originalLine[k] !== null && newLine[k] !== null && originalLine[k].id !== newLine[k].id)) {
                           changed = true;
                           break;
                        }
                    }
                    
                    dir.set(i, newLine);
                }
                
                // Update the main board array
                board = Array(gridSize).fill(null).map(() => Array(gridSize).fill(0));
                tiles.forEach(t => {
                    if (!t.merged) {
                        board[t.r][t.c] = t.value;
                    }
                });

                return { changed, score: moveScore };
            }

            // --- Game State Checks ---
            function checkGameOver() {
                // Any empty cells?
                if (tiles.length < gridSize * gridSize) {
                    return false;
                }
                // Any possible merges?
                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        const val = board[r][c];
                        if (c < gridSize - 1 && val === board[r][c + 1]) return false;
                        if (r < gridSize - 1 && val === board[r + 1][c]) return false;
                    }
                }
                return true;
            }

            function winGame() {
                hasWon = true;
                isGameLocked = true;
                messageText.textContent = "你赢了!";
                continueBtn.style.display = 'inline-block';
                restartBtn.textContent = '重新开始';
                messageOverlay.classList.add('show');
            }

            function endGame() {
                isGameLocked = true;
                messageText.textContent = "游戏结束!";
                continueBtn.style.display = 'none';
                restartBtn.textContent = '再试一次';
                messageOverlay.classList.add('show');
            }

            // --- Event Listeners ---
            function handleKeyPress(e) {
                switch (e.key) {
                    case 'ArrowUp': handleInput('Up'); break;
                    case 'ArrowDown': handleInput('Down'); break;
                    case 'ArrowLeft': handleInput('Left'); break;
                    case 'ArrowRight': handleInput('Right'); break;
                }
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                    e.preventDefault();
                }
            }

            let touchStartX = 0, touchStartY = 0, touchEndX = 0, touchEndY = 0;

            gameBoardContainer.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            });

            gameBoardContainer.addEventListener('touchend', (e) => {
                touchEndX = e.changedTouches[0].screenX;
                touchEndY = e.changedTouches[0].screenY;
                handleSwipe();
            });

            function handleSwipe() {
                const dx = touchEndX - touchStartX;
                const dy = touchEndY - touchStartY;
                if (Math.max(Math.abs(dx), Math.abs(dy)) > 30) { // Swipe threshold
                    if (Math.abs(dx) > Math.abs(dy)) {
                        handleInput(dx > 0 ? 'Right' : 'Left');
                    } else {
                        handleInput(dy > 0 ? 'Down' : 'Up');
                    }
                }
            }
            
            newGameBtn.addEventListener('click', initGame);
            restartBtn.addEventListener('click', initGame);
            continueBtn.addEventListener('click', () => {
                isGameLocked = false;
                messageOverlay.classList.remove('show');
            });
            document.addEventListener('keydown', handleKeyPress);

            // Start Game
            initGame();
        });
    </script>
</body>
</html>